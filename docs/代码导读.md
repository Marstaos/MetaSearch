# MetaSearch 代码导读

MetaSearch的代码结构清晰、注释完整，非常适合学习现代大模型应用开发。这份代码导读帮助你快速理解项目架构和核心实现。

## 1. 项目整体结构

MetaSearch采用模块化设计，主要包含以下目录结构：

```
MetaSearch/
├── config/           # 配置文件
├── deepsearch/       # 核心代码
│   ├── indexing/     # 索引相关代码
│   ├── llm/          # LLM接口
│   ├── preprocessing/# 预处理代码
│   ├── rag/          # RAG实现
│   ├── retrieval/    # 检索相关代码
│   └── utils/        # 工具函数
├── scripts/          # 脚本工具
├── app.py            # 应用入口
```

## 2. 核心模块详解

### 2.1 配置系统 (config/)

配置文件采用YAML格式，集中管理所有参数，便于调整和实验：

```yaml
# 模型配置、路径配置、检索参数等
models:
  embedding: {...}
  reranker: {...}
  llm: {...}
```

**学习要点**：了解如何使用YAML进行配置管理，以及如何在代码中加载和使用配置。

### 2.2 预处理模块 (deepsearch/preprocessing/)

负责文档的加载、分块和初步处理：

- `document.py`: 实现文档分块、生成摘要等功能
- 文本分块采用固定大小+重叠的策略

**学习要点**：了解文档预处理的基本流程，特别是如何将长文本分割成适合检索的小块。

### 2.3 索引模块 (deepsearch/indexing/)

实现了三种不同的索引方式：

- `vector_index.py`: 向量索引，使用FAISS库实现高效相似度搜索
- `tfidf_index.py`: 关键词索引，基于TF-IDF算法
- `kg_index.py`: 知识图谱索引，基于实体关系

每个索引模块都包含两个主要类：
- `XXXIndexBuilder`: 负责构建索引
- `XXXRetriever`: 负责检索

**学习要点**：理解不同索引方式的原理和实现，以及如何结合多种索引提高检索效果。

### 2.4 检索模块 (deepsearch/retrieval/)

- `searcher.py`: 实现了`CombinedSearcher`类，融合多种检索方式
- `ranker.py`: 实现了`ReRanker`类，对检索结果进行重排序

**学习要点**：学习如何结合多种检索结果，以及如何使用重排序提高检索质量。

### 2.5 LLM接口 (deepsearch/llm/)

- `model.py`: 实现了LLM的工厂类和接口封装
  - `LLMFactory`: 创建不同类型的LLM（API或本地）
  - `LocalLLM`: 本地模型的封装

**学习要点**：了解如何封装和统一不同来源的LLM接口，实现可替换的模型层。

### 2.6 RAG核心实现 (deepsearch/rag/)

- `deep_rag.py`: 实现了深度迭代检索的核心逻辑
- `query_expander.py`: 实现查询扩展，生成子查询

**学习要点**：这是项目的核心部分，重点理解深度迭代检索的实现逻辑和信息增长率的计算方式。

## 3. 工作流程解析

### 3.1 文档处理流程

```python
# 1. 加载文档
# 2. 分割成chunks
# 3. 为每个chunk生成摘要
# 4. 保存处理结果
```

### 3.2 索引构建流程

```python
# 1. 加载chunks
# 2. 构建向量索引
# 3. 构建TF-IDF索引
# 4. 构建知识图谱索引
```

### 3.3 查询处理流程

```python
# 1. 接收用户查询
# 2. 执行初始检索
# 3. 生成子查询
# 4. 执行多轮迭代检索
# 5. 计算信息增长率，决定是否继续
# 6. 生成最终回答
```

## 4. 关键算法详解

### 4.1 深度迭代检索算法

深度迭代检索是MetaSearch的核心创新，其基本流程为：

1. 对原始查询执行标准RAG
2. 基于检索结果生成多个子查询
3. 对每个子查询执行检索
4. 计算信息增长率，决定是否继续迭代
5. 合并所有检索结果，生成最终回答

关键代码位于`deepsearch/rag/deep_rag.py`中的`answer`方法。

### 4.2 查询扩展算法

查询扩展是深度迭代检索的关键环节，通过LLM生成多个相关子查询，探索更广泛的知识空间：

1. 分析当前查询和回答
2. 生成候选子查询
3. 对子查询进行评分和筛选
4. 返回最相关的子查询

关键代码位于`deepsearch/rag/query_expander.py`中的`extend_query`和`generate_subquery`方法。

### 4.3 多样性重排序算法

为了避免检索结果的冗余，系统使用MMR(Maximal Marginal Relevance)算法在相关性和多样性之间取得平衡：

1. 计算查询与文档的相关性得分
2. 计算文档之间的相似度
3. 综合考虑相关性和多样性进行排序

关键代码位于`deepsearch/retrieval/ranker.py`中的`rerank_with_mmr`方法。

## 5. 学习路径建议

### 5.1 初学者路径

1. 首先运行完整系统，体验功能
2. 阅读`app.py`了解系统初始化和工作流程
3. 学习`preprocessing`模块，了解文档处理
4. 学习`indexing`模块中的一种索引实现（建议从`vector_index.py`开始）
5. 学习`llm`模块，了解大模型接口

### 5.2 进阶学习路径

1. 深入学习`rag`模块，特别是深度迭代检索的实现
2. 学习`retrieval`模块中的重排序算法
3. 比较不同索引方式的实现和效果
4. 尝试修改配置参数，观察系统行为变化
5. 尝试扩展系统，添加新的索引方式或改进算法

## 6. 常见问题解答

1. **为什么需要多种索引方式？**
   - 不同索引方式有各自优势，向量索引擅长语义相似性，关键词索引擅长精确匹配，知识图谱索引擅长实体关系

2. **信息增长率如何计算？**
   - 新发现文档数量与已知文档数量的比值，用于判断是否继续迭代

3. **如何调整系统平衡效率和效果？**
   - 主要通过配置文件调整参数，如迭代次数、候选数量等

4. **如何扩展支持新的文档类型？**
   - 在`preprocessing`模块中添加新的文档处理函数

祝你学习愉快！